
> https://www.bilibili.com/video/BV13g41157hK?spm_id_from=333.788.player.switch&vd_source=9617a6202b7950f4cc8427b1cfd96eb2&p=3
> 左神：左程云

0.常见时间复杂度排序
    O(1) - 常数时间复杂度
        无论输入数据量如何，执行时间都是常数。这是最优的时间复杂度。
        示例：访问数组中的某个元素。
    O(log N) - 对数时间复杂度
        执行时间随着输入数据量的增长而缓慢增长。常见于二分查找等算法。
        示例：二分查找。
    O(N) - 线性时间复杂度
        执行时间与输入数据量成正比。常见于遍历数组等操作。
        示例：线性搜索。
    O(N log N) - 线性对数时间复杂度
        执行时间与输入数据量的对数成正比。常见于高效的排序算法，如归并排序和快速排序。
        示例：归并排序、快速排序。
    O(N^2) - 平方时间复杂度
        执行时间与输入数据量的平方成正比。常见于嵌套循环。
        示例：冒泡排序、选择排序。
    O(N^d) - 多项式时间复杂度
        执行时间与输入数据量的多项式成正比。d 是一个常数。
        示例：多层嵌套循环。
    O(2^N) - 指数时间复杂度
        执行时间随着输入数据量的增加呈指数增长。常见于某些递归算法和组合问题。
        示例：子集生成、旅行商问题的暴力解法。
    O(N!) - 阶乘时间复杂度
        执行时间随着输入数据量的增加呈阶乘增长。常见于某些排列问题。
        示例：旅行商问题的暴力解法。

1.评价算法流程的好坏：$1_testFN
    1.先看时间复杂度的指标
    2.再分析不同数据样本下的实际运行时间，也就是常数项时间。
    3.例如：O(f(N))分别有10n^2  和 100n^2 ，并不是根据10和100去比较谁好谁坏，而是根据他的运行时间去比的
    4.示例：时间复杂度比较
        时间复杂度一致时，比的不是常数项。而是常数项所运行的时间，因为你不清楚它里面是使用的位运算还是算数运算，而位运算要快于算数运算

2.位与运算
    1.&: 如果两个对应的位都是1，则结果位为1；否则为0 ，a & b 读作 "a 按位与 b" 或者 "a AND b"。
    2.^: 不同为1相同为0的计算方式，无进位相加 ，，a ^ b 读作 "a 按位异或 b" 或者 "a XOR b"

3.对数器的概念和使用
    1.用来测试自己实现算法的逻辑是否正确。使用随机样本来测试算法是否正确。

4.递归行为和时间复杂度估算
    master公式：
        T(N) = a*T(N/b) + f(N^d);
        统一符合以上规范的递归，他的时间复杂度可以直接计算：
        T(N) 表示递归母问题的时间复杂度，N表示递归的输入规模。
        a表示递归的子问题调用次数，b表示子问题的规模，f(N^d)表示递归的常数项，d表示递归的常数项的指数。
        ---------------
        如果将LR之间的区域划分为均等三份分别求最大值，则时间复杂度公式为：
        T(n) = 3T(n/3)+O(1) ，3表示3次 n/3表示数据规模，也符合master公式
        如果将LR直接的区域分为两份，左边1/3，右边2/3，则时间复杂度为：
        T(n) = T(n/3)+T(2n/3)+O(1)，此时就不符合master公式
        如果将LR之间的区域划分为均等2份分别求最大值，并且求出最大值后打印出来，则时间复杂度为：
        T(n) = 2T(n/2)+O(n) 
    然后根据master公式推导，可以得到准确的时间复杂度为：log(b,a)代表以b为底，a次方
        log(b,a) > d   O(Nlog(b,a))，（简化为 O(N)）
        log(b,a) = d   O(N^d * logN)
        log(b,a) < d   O(N^d)
    示例中：master公式为
        T(n) = 2T(n/2)+O(1)
        带入后，计算
        log(2,2) = 1 > 0，所以最后的时间复杂度为  O(Nlog(b,a))

